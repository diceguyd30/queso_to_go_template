const settings = require('./settings.js');
const twitch = require('./twitch.js').twitch();
const fs = require('fs');
const standardBase30 = '0123456789abcdefghijklmnopqrst'
const nintendoBase30 = '0123456789BCDFGHJKLMNPQRSTVWXY'
const arbitraryXorValue = 377544828 

var current_level = undefined;
var levels = new Array();
const cache_filename = "queso.save";

const delim = "[-\. ]?";
const code = "[A-Ha-hJ-Nj-nP-Yp-y0-9]{3}";
const codeStrict = "[A-Ha-hJ-Nj-nP-Yp-y0-9]{2}[fghFGH]";
const levelCodeRegex = new RegExp(`(${code})${delim}(${code})${delim}(${codeStrict})`);

// This function returns true if the course id given to it is a valid course id. The optional parameter dataIdThresHold
// will make the function return false if the data id of the submitted level is greater than it.
// For max data id threshold, if you only want to have a max maker id threshold, send the 2nd argument as null.
function courseIdValidity(courseIdString, dataIdCourseThreshold, dataIdMakerThreshold)
{
    
    let reversedString = courseIdString.split("").reverse()
    reversedString = reversedString.map(c => standardBase30[nintendoBase30.indexOf(c)]).join('')
    let courseBits = parseInt(reversedString, 30)

    let courseBitsString = courseBits.toString(2)
    if (courseBitsString.length !== 44)
    {
        return false
    }
    let dataId = parseInt(courseBitsString.substring(32, 44).concat((courseBitsString.substring(10, 30))),2) ^ arbitraryXorValue
    let fieldA = parseInt(courseBitsString.substring(0, 4),2)
    let fieldB = parseInt(courseBitsString.substring(4, 10),2)
    let fieldD = parseInt(courseBitsString.substring(30, 31,2))
    let fieldE = parseInt(courseBitsString.substring(31, 32,2))

    if (fieldA !== 8 || fieldB !== (dataId - 31) % 64 || (fieldD == 0 && dataId < 3000004) || fieldE != 1)
    {
        return false
    }
    else if (typeof dataIdMakerThreshold === 'number' && fieldD == 1) 
    {
        return dataId <= dataIdMakerThreshold;
    } 
    else if (typeof dataIdCourseThreshold === 'number' && fieldD == 0)
    {
        return dataId <= dataIdCourseThreshold;
    }

    return true;
}

// this function extracts a level code found in someones message
// and returns that level code (if possible) and also checks it's validity
// the returned object will contain
// - a `code` field which either contains the found level/maker code or the original message
// - a `valid` field which will be true iff a level/maker code has the correct syntax and is one that can be generated by the game
// - and a `validSyntax` field which will be true iff a level/maker code has the correct syntax 
const extractValidCode = (levelCode) => {
  let match = levelCode.match(levelCodeRegex);
  if (match) {
    let courseIdString = `${match[1]}${match[2]}${match[3]}`.toUpperCase();
    let validity = courseIdValidity(courseIdString, settings.dataIdCourseThreshold, settings.dataIdMakerThreshold);
    return { code: `${match[1]}-${match[2]}-${match[3]}`, valid: validity, validSyntax: true };
  }
  return { code: levelCode, valid: false, validSyntax: false };
}

const queue = {
  add: (level) => {
    if (levels.length >= settings.max_size) {
      return "Sorry, the level queue is full!";
    }
    let code = extractValidCode(level.code);
    level.code = code.code;
    if (!code.valid) {
      return "I'm pretty sure '" + level.code + "' isn't a valid code" + (code.validSyntax ? " because it can't be generated by the game" : "") + ". Try again.";
    }
    if (current_level != undefined && current_level.submitter == level.submitter && level.submitter != settings.channel) {
      return "Wait for your level to be completed before you submit again.";
    }

    var result = levels.find(x => x.submitter == level.submitter);
    if (result == undefined || level.submitter == settings.channel) {
      levels.push(level);
      queue.save();
      return level.submitter + ", " + level.code + " has been added to the queue.";
    } else {
      return "Sorry, viewers are limited to one submission at a time.";
    }
  },

  modRemove: (username) => {
    if (username == '') {
      return "You can use !remove <username> to kick out someone else's level;  if you want to skip the current one, use !next.";
    }

    levels = levels.filter(x => x.submitter != username);
    return "Ok, I removed " + username + "'s level from the queue.";
  },

  remove: (username) => {
    if (current_level != undefined && current_level.submitter == username) {
      return "We're playing that level right now!  Don't take this away from us!";
    }
    levels = levels.filter(x => x.submitter != username);
    return username + "'s level removed from the queue.";
  },

  replace: (username, new_level_code) => {
    let code = extractValidCode(new_level_code);
    new_level_code = code.code;
    if (!code.valid) {
      return "I'm pretty sure '" + new_level_code + "' isn't a valid code" + (code.validSyntax ? " because it can't be generated by the game" : "") + ".  Try again.";
    }
    var old_level = levels.find(x => x.submitter == username);
    if (old_level != undefined) {
      old_level.code = new_level_code;
      queue.save();
      return "Ok " + username + ", your code in the queue is now " + new_level_code + ".";
    } else if (current_level != undefined && current_level.submitter == username) {
      current_level.code = new_level_code;
      queue.save();
      return "Ok " + username + ", your code in the queue is now " + new_level_code + ".";
    } else {
      return "I didn't find a level for " + username + " in the queue. Use !add to add one.";
    }
  },

  position: async (username) => {
    if (current_level != undefined && current_level.submitter == username) {
      return 0;
    }
    if (levels.length == 0) {
      return -1;
    }

    var list = await queue.list();
    var both = list.online.concat(list.offline);
    var index = both.findIndex(x => x.submitter == username);
    if (index != -1) {
      return (index + 1) + ((current_level != undefined) ? 1 : 0);
    }
    return -1;
  },

  punt: async () => {
    if (current_level === undefined) {
      return "The nothing you aren't playing cannot be punted.";
    }
    var top = current_level;
    current_level = undefined;
    queue.add(top);
    return 'Ok, adding the current level back into the queue.';
  },

  next: async () => {
    var list = await queue.list();
    var both = list.online.concat(list.offline);
    if (both.length === 0) {
      current_level = undefined;
    } else {
      current_level = both.shift();
    }
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  subnext: async () => {
    var list = await queue.sublist();
    var both = list.online.concat(list.offline);
    if (both.length === 0) {
      current_level = undefined;
    } else {
      current_level = both.shift();
    }
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  modnext: async () => {
    var list = await queue.modlist();
    var both = list.online.concat(list.offline);
    if (both.length === 0) {
      current_level = undefined;
    } else {
      current_level = both.shift();
    }
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  dip: (username) => {
    var index = levels.findIndex(x => x.submitter == username);
    if (index != -1) {
      current_level = levels[index];
      levels.splice(index, 1);
      queue.save();
      return current_level;
    }
    return undefined;
  },

  current: () => {
    return current_level;
  },

  random: async () => {
    var list = await queue.list();
    var eligible_levels = list.online;
    if (eligible_levels.length == 0) {
      eligible_levels = list.offline;
      if (eligible_levels.length == 0) {
        current_level = undefined;
        return current_level;
      }
    }

    var random_index = Math.floor(Math.random() * eligible_levels.length);
    current_level = eligible_levels[random_index];
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  subrandom: async () => {
    var list = await queue.sublist();
    var eligible_levels = list.online;
    if (eligible_levels.length == 0) {
      eligible_levels = list.offline;
      if (eligible_levels.length == 0) {
        current_level = undefined;
        return current_level;
      }
    }

    var random_index = Math.floor(Math.random() * eligible_levels.length);
    current_level = eligible_levels[random_index];
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  modrandom: async () => {
    var list = await queue.modlist();
    var eligible_levels = list.online;
    if (eligible_levels.length == 0) {
      eligible_levels = list.offline;
      if (eligible_levels.length == 0) {
        current_level = undefined;
        return current_level;
      }
    }

    var random_index = Math.floor(Math.random() * eligible_levels.length);
    current_level = eligible_levels[random_index];
    var index = levels.findIndex(x => x.code == current_level.code);
    levels.splice(index, 1);
    queue.save();
    return current_level;
  },

  list: async () => {
    var online = new Array();
    var offline = new Array();
    await twitch.getOnlineUsers(settings.channel).then(online_users => {
      online = levels.filter(x => online_users.has(x.username));
      offline = levels.filter(x => !online_users.has(x.username));
    });
    return {
      online: online,
      offline: offline
    };
  },

  sublist: async () => {
    var online = new Array();
    var offline = new Array();
    await twitch.getOnlineSubscribers(settings.channel).then(online_users => {
      online = levels.filter(x => online_users.has(x.username));
      offline = levels.filter(x => !online_users.has(x.username));
    });
    return {
      online: online,
      offline: offline
    };
  },

  modlist: async () => {
    var online = new Array();
    var offline = new Array();
    await twitch.getOnlineMods(settings.channel).then(online_users => {
      online = levels.filter(x => online_users.has(x.username));
      offline = levels.filter(x => !online_users.has(x.username));
    });
    return {
      online: online,
      offline: offline
    };
  },

  save: () => {
    var levels_to_save = levels;
    if (current_level != undefined) {
      levels_to_save = [current_level].concat(levels_to_save);
    }
    var new_data = JSON.stringify(levels_to_save, null, 2);
    fs.writeFileSync(cache_filename, new_data);
  },

  load: () => {
    if (fs.existsSync(cache_filename)) {
      var raw_data = fs.readFileSync(cache_filename);
      levels = JSON.parse(raw_data);
      const username_missing = level => !level.hasOwnProperty('username');
      if (levels.some(username_missing)) {
        console.warn(`Usernames are not set in the file ${cache_filename}!`);
        console.warn('Assuming that usernames are lowercase Display Names which does work with Localized Display Names.');
        console.warn('To be safe, clear the queue with !clear.');
        levels.forEach(level => {
          if (username_missing(level)) {
            level.username = level.submitter.toLowerCase();
          }
        });
      }
      current_level = undefined;
    }
  },

  clear: () => {
    current_level = undefined;
    levels = new Array();
    queue.save();
  }
};

module.exports = {
  quesoqueue: () => { return queue; }
};
